метод Скрипт()
    // Создаем граф в виде соответствия:
    // Ключ — узел (вершина), значение — массив соседних узлов (связей)
    знч Граф = <Строка, Массив<Строка>>{
        "A": ["B", "C"],   // Из A можно перейти в B и C
        "B": ["D", "E"],   // Из B можно перейти в D и E
        "C": ["F"],        // Из C можно перейти только в F
        "D": <Строка>[],   // D — тупиковая вершина (нет соседей)
        "E": ["F"],        // Из E можно перейти в F
        "F": <Строка>[]    // F — конечная вершина (нет соседей)
    }  

    // Запускаем поиск в глубину (DFS) из вершины "A" в вершину "F"
    ПоискВГлубину_Итеративный(Граф, "A", "F")
;

// Итеративная реализация DFS
// Выводит последовательность посещаемых узлов и сообщает, найдена ли цель
метод ПоискВГлубину_Итеративный(Граф: Соответствие<Строка, Массив<Строка>>, Начало: Строка, Цель: Строка)

    // Стек для хранения вершин, которые нужно обработать (LIFO)
    знч Стек = [Начало]

    // Множество посещённых узлов (реализуем через Соответствие)
    знч Посещено = <Строка, Булево>{:}

    пока Стек.Размер() > 0

        // Извлекаем вершину из вершины стека (последний элемент)
        пер Узел = Стек.УдалитьПоИндексу(Стек.Размер() - 1)

        // Пропускаем, если уже посещали (может возникнуть при добавлении дублей)
        если Посещено.СодержитКлюч(Узел) 
            продолжить
        ;

        // Помечаем как посещённую
        Посещено.Вставить(Узел, Истина)

        Консоль.Записать("Посещаем: $Узел")

        // Проверяем, достигли ли цели
        если Узел == Цель
            Консоль.Записать("Найден узел: $Цель")
            возврат // Можно добавить возврат Истина, если нужно значение
        ;

        // Получаем соседей текущего узла       
        пер Соседи = Граф.СодержитКлюч(Узел) ? Граф[Узел] : новый Массив<Строка>()
        
        // Добавляем соседей в стек в **обратном порядке**, чтобы первый сосед
        // обрабатывался первым (имитация рекурсивного порядка)
        // Например, если соседи: ["B", "C"], то в стек добавим сначала "C", потом "B"
        // Тогда при извлечении сначала будет "B" (потому что стек — LIFO)
        для Индекс = Соседи.Граница() вниз по 0
            пер Сосед = Соседи[Индекс]
            // Добавляем в стек даже если уже посещён — проверка будет при извлечении
            Стек.Добавить(Сосед)
        ;

    ;
    // Если вышли из цикла — путь не найден
    Консоль.Записать("Цель $Цель не найдена.")
;
